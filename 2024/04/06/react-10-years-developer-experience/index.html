<!DOCTYPE html><html lang="zh-TW"><head><meta charset="utf-8"><meta name="theme-color" content="#0077B5"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="tfWfY4bkeILtxNyUg9UGfVkCNvKtAauF2r9WDQs8kBM"><meta property="fb:pages" content="219138595338413"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="嗨，我是林彥成，是個喜歡爬山的前端工程師，專注在 React.js 的相關開發，這個部落格會分享網站技術、職涯發展、個人成長和產業觀察相關文章。"><meta name="keyword" content="前端三分鐘, 前端, React.js, 林彥成, 網站技術, 職涯發展, 個人成長, 產業觀察"><meta property="og:image" content="/img/icon_wechat.png"><link rel="shortcut icon" href="/img/favicon.ico"><title>Reactjs 問世十年後的開發體驗: 一袋米扛幾樓的難度有多少 | 前端三分鐘 | 一起用三分鐘分享技術與知識</title><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"><link rel="canonical" href="https://linyencheng.github.io/2024/04/06/react-10-years-developer-experience/"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/blog.min.css"><link rel="stylesheet" href="/css/highlight.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/feed.xml" title="前端三分鐘" type="application/atom+xml"></head><body ontouchstart=""><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"><button type="button" class="navbar-toggle"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">前端三分鐘</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a title="首頁" href="/">首頁</a></li><li><a href="/categories/">分類</a></li><li><a href="/about/">關於</a></li><li><a href="/archives/">列表</a></li><li><a href="/tags/">標籤</a></li><li><a title="隱私權政策" href="/pravicy">隱私權政策</a></li></ul></div></div></div></nav><script async>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");function handleMagic(e){0<$navbar.className.indexOf("in")?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}$toggle.addEventListener("click",handleMagic)</script><style>.intro-header{position:relative;overflow:hidden;background:repeating-linear-gradient(0deg,rgba(255,255,255,.3) 0,rgba(255,255,255,.3) 1px,transparent 1px,transparent 10px),repeating-linear-gradient(90deg,rgba(255,255,255,.3) 0,rgba(255,255,255,.3) 1px,transparent 1px,transparent 10px);background-color:#b4dbf8}@media (max-width:768px){.mobile-hidden{display:none}}</style><progress value="0" id="progressBar" class="flat"><div class="progress-container"><span class="progress-bar"></span></div></progress><header class="intro-header"><div class="geometric-pattern"><div class="shape"></div><div class="shape"></div><div class="shape"></div><div class="shape mobile-hidden"></div><div class="shape mobile-hidden"></div><div class="shape mobile-hidden"></div></div><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><div class="tags"><a class="tag" href="/tags/#JavaScript" title="JavaScript">JavaScript</a> <a class="tag" href="/tags/#網站技術" title="網站技術">網站技術</a> <a class="tag" href="/tags/#React.js" title="React.js">React.js</a></div><h1 class="mb-0"><span>Reactjs 問世十年後的開發體驗</span> <span class="subheading mb-2">一袋米扛幾樓的難度有多少</span></h1><a class="post-user-meta post-user-meta--big" href="/about"><img loading="lazy" alt="me" class="userPhoto d-inline-block" src="/img/me_icon.jpg"><div class="d-inline-block"><span class="user-name" style="color:#fff">林彥成</span><br><span style="color:#fff">2024-04-06 | 11 min.</span> <span id="viewCountTotal" style="color:#fff"></span></div></a></div></div></div></div></header><article id="article-post"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container"><div id="toc" class="toc-article"><strong class="toc-title h3">文章目錄</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B3%87%E6%96%99%E5%B1%A4-Flux-%E6%9E%B6%E6%A7%8B%E3%80%81Redux"><span class="toc-number">1.</span> <span class="toc-text">資料層: Flux 架構、Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Store-Rudux"><span class="toc-number">1.1.</span> <span class="toc-text">Store: Rudux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Store-Zustand"><span class="toc-number">1.2.</span> <span class="toc-text">Store: Zustand</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A5%AD%E5%8B%99%E9%82%8F%E8%BC%AF%E5%B1%A4-React-Hooks"><span class="toc-number">2.</span> <span class="toc-text">業務邏輯層: React Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API-Hooks-SWR%E3%80%81React-Query"><span class="toc-number">2.1.</span> <span class="toc-text">API Hooks: SWR、React Query</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%95%E7%A4%BA%E5%B1%A4-JSX%E3%80%81CSS-in-JS"><span class="toc-number">3.</span> <span class="toc-text">展示層: JSX、CSS-in-JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reconciliation-Virtual-DOM%E3%80%81Fiber-Tree"><span class="toc-number">3.1.</span> <span class="toc-text">Reconciliation: Virtual DOM、Fiber Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E4%BB%B6%E5%88%86%E9%A1%9E%E8%88%87%E9%80%B1%E6%9C%9F-React-Class-Component%E3%80%81Functional-Component"><span class="toc-number">3.2.</span> <span class="toc-text">元件分類與週期: React Class Component、Functional Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E4%BB%B6%E9%96%8B%E7%99%BC-Storybookjs"><span class="toc-number">3.3.</span> <span class="toc-text">元件開發: Storybookjs</span></a></li></ol></li></ol></div><br><div class="google-ad"><ins class="adsbygoogle" style="display:block" data-ad-format="fluid" data-ad-layout-key="-h4+1+1q-1t-2x" data-ad-client="ca-pub-1297466993744883" data-ad-slot="9012117796"></ins></div><p>Reactjs 從 2013 年問世後至今滿 10 年，提供前端開發領域元件設計的典範基礎，逐步帶動並完善了開發的生態系統。</p><p>最初的 React 就是一個單純的函式，提供 props 並進行內部的狀態運算後回傳一個計算後的 DOM 元素呈現在網頁上。</p><blockquote><p>DOM &#x3D; React(props, state)</p></blockquote><p>回顧過去的十年，Reactjs 的發展從 Clean Architecture 角度來看主要圍繞以下三個層面：</p><ul><li>資料層：單向資料流</li><li>業務邏輯層：Hooks</li><li>展示層：JSX、CSS-in-JS</li></ul><blockquote><p><img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg"><br>圖片來源: <a target="_blank" rel="noopener" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a></p></blockquote><p>在 2024 年 Reactjs 的開發體驗將會是什麼樣子呢？</p><p>React 近十年的發展下來，在 2022 React 18 版本釋出後停滯了接近兩年，下一個主要版本 19 會是著重在新的渲染引擎，從官方的 Github 可可以看出接下來的 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/pull/28843">React 18.3</a> 主要是為了接下來的 <a target="_blank" rel="noopener" href="https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024">React 19 版</a>做準備，部落格可以看出 React 19 將減少開發者撰寫多餘的 hook，最終的目的是簡化開發流程，降低開發人員的學習成本，提供更簡潔的開發體驗與更高的開發效率。</p><p>相較於同樣有著包袱的隔壁棚 Angular 每次升級幾乎都是 Breaking Change，React 從最初的簡單函式庫在經歷了多次版本迭代，繼續背著承重的歷史包袱帶著大家繼續前行。</p><p>相對於 React、Angular，較沒有人員和程式碼包袱的 Vue 和 Svelte 也都在 React 和 Angular 的肩膀上提供了不錯的解決方案，至於最新的 React Server Components 要讓 React 一袋米扛幾樓? Next.js 和 RedwoodJS 正在嘗試著給出好的答案。</p><h2 id="資料層-Flux-架構、Redux"><a href="#資料層-Flux-架構、Redux" class="headerlink" title="資料層: Flux 架構、Redux"></a>資料層: Flux 架構、Redux</h2><blockquote><p>Reactjs 提出單向資料流（Unidirectional Data Flow）的概念，強調資料的不可變性（Immutability）</p></blockquote><p>Flux 架構提供資料管理方案，小編早期接觸過 <a target="_blank" rel="noopener" href="https://alt.js.org/">Alt</a> 和 <a target="_blank" rel="noopener" href="https://redux.js.org/">Redux</a> 兩種，Flux 用單向資料流取代傳統的 MVC，這意資料從單一入口 (動作) 進入，然後透過狀態管理器 (Store) 向外流動，最後到達畫面 (view)，畫面又可以透過呼叫其他動作來回應使用者輸入，重新開始資料流的流程。</p><p>早期的 Redux 有個問題就是會產生很多的 Code Boilerplate，開發過程中會很常需要複製貼上許多類似架構的程式碼，官方後來還推出 <a target="_blank" rel="noopener" href="https://redux.js.org/recipes/reducing-boilerplate">Redux Toolkits 來協助寫法簡化</a>，本來要維護三個地方，現在變成只要維護一份配置檔就好了。</p><h3 id="Store-Rudux"><a href="#Store-Rudux" class="headerlink" title="Store: Rudux"></a>Store: Rudux</h3><p>為什麼需要 Redux? 使用與否的差異在哪?</p><p>直接開始一個情境，我們想像一個頁面中有三個元件:</p><ol><li>元件一: 登入按鈕區塊，登入後顯示 hello, XXX (XXX 為學生名稱)</li><li>元件二: 顯示登入後撈回的各科成績資料</li><li>元件三: 更改學生姓名區塊</li></ol><p>那麼有或沒有 Redux 的情況下，要怎麼實作這樣的頁面呢？關鍵需要解決的問題就是元件之間溝通的問題:</p><ul><li>沒有 Redux 時: 使用 Container 元件來管理狀態，把以上三個子元件都放在容器裡，並在容器中寫幾個 callback function 當作 props 傳進子元件中，讓子元件可以在改變狀態時,把改變的狀態及時回傳到容器裡，這就是官方文件中寫的 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/lifting-state-up.html">Lift State Up</a></li></ul><blockquote><p><img src="https://react.dev/_next/image?url=/images/docs/diagrams/passing_data_lifting_state.dark.png&w=640&q=75"><br>Lift State up: <a target="_blank" rel="noopener" href="https://react.dev/learn/passing-data-deeply-with-context">https://react.dev/learn/passing-data-deeply-with-context</a></p></blockquote><ul><li>有 Redux 後: 最大的改變就是，Lift State Up to Store，把狀態統一管理避免 Prop drilling 維持 Single Source of Truth，所有的來源都是來自於一個可被預測的地方，開發工具因此可以做到時空旅行，讓狀態停在任意想要的時間點</li></ul><blockquote><p><img src="https://react.dev/_next/image?url=/images/docs/diagrams/passing_data_prop_drilling.dark.png&w=640&q=75"><br>Prop drilling: <a target="_blank" rel="noopener" href="https://react.dev/learn/passing-data-deeply-with-context">https://react.dev/learn/passing-data-deeply-with-context</a></p></blockquote><p>使用 Redux ToolKits 後按照功能搭配分類，以剛剛 Clean Architecture 角度來說就是針對 Entities 分類，小編覺得這種配置會比較適合大型專案，舉例來說依照不同的腳色功能就會分成</p><ul><li>typeOne</li><li>typeTwo</li><li>typeThree</li></ul><p>用常見的拍賣網站來說就像是買家、普通賣家、商城賣家，而每個功能所需要的 action、components、containers、reducers 都會放在一起，所以在開發時，每個工程師都可以在獨立的資料夾中完成該次的任務。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">└── features</span><br><span class="line">    ├── typeOne</span><br><span class="line">    │   ├── TypeOne.js</span><br><span class="line">    │   ├── TypeOne.styles.scss</span><br><span class="line">    │   └── typeOneSlice.js</span><br><span class="line">    ├── typeTwo</span><br><span class="line">    │   ├── TypeTwo.js</span><br><span class="line">    │   ├── TypeTwo.styles.scss</span><br><span class="line">    │   └── typeTwoSlice.js</span><br><span class="line">    └── typeThree</span><br><span class="line">        ├── TypeThree.js</span><br><span class="line">        ├── TypeThree.styles.scss</span><br><span class="line">        └── typeThreeSlice.js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;counter&quot;</span>,</span><br><span class="line">  initialState,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">value</span>++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">value</span>--;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">incrementByAmount</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">      state.<span class="property">value</span> += action.<span class="property">payload</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, incrementByAmount &#125; = counterSlice.<span class="property">actions</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span>;</span><br></pre></td></tr></table></figure><p>以程式碼的架構面來說，使用 Redux 是一個重大的決定，從寫法上看來幾乎是穿透了專案所有地方，從 GUI 上的 Action 需要透過特殊的方式 Dispatch 一直到打 API 的 middleware 一直到 Global 的 Store，所以也才演變出 Container 和 Component 的概念，還是盡量讓元件是可以高度重用的設計。</p><h3 id="Store-Zustand"><a href="#Store-Zustand" class="headerlink" title="Store: Zustand"></a>Store: Zustand</h3><p>隨著時間的演進，最近有越來越多管理狀態的工具，以概念上來說粗分為三種流派 Atom、Store、Proxy，如果以最傳統的 Store 概念來說，Zustand 是小編目前用過最簡單的，最基本的 store 只要短短幾行就完成配置，如果想要看看小編的推坑文，歡迎繼續閱讀<a href="https://linyencheng.github.io/2024/10/02/react/react-store-zustand/">為什麼選擇 Zustand 作為最佳狀態管理解決方案 </a>這篇文章。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; create &#125; <span class="keyword">from</span> <span class="string">&quot;zustand&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useStore = <span class="title function_">create</span>(<span class="function">(<span class="params">set</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">inc</span>: <span class="function">() =&gt;</span> <span class="title function_">set</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;)),</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>程式碼架構上來說，因為是使用 hook 的關係，所以剩下只需要在元件中透過 hook 的概念將 Store 掛載進去元件進行使用即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, inc &#125; = <span class="title function_">useStore</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;inc&#125;</span>&gt;</span>one up<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在專案架構上 Zustand 除了 hook 以外也提供了不同的架構方式，不使用 hook 而透過直接當模組使用的方式也讓元件的呈現能更為簡潔。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useDogStore = <span class="title function_">create</span>(<span class="function">() =&gt;</span> (&#123; <span class="attr">paw</span>: <span class="literal">true</span>, <span class="attr">snout</span>: <span class="literal">true</span>, <span class="attr">fur</span>: <span class="literal">true</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getting non-reactive fresh state</span></span><br><span class="line"><span class="keyword">const</span> paw = useDogStore.<span class="title function_">getState</span>().<span class="property">paw</span>;</span><br><span class="line"><span class="comment">// Listening to all changes, fires synchronously on every change</span></span><br><span class="line"><span class="keyword">const</span> unsub1 = useDogStore.<span class="title function_">subscribe</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// Updating state, will trigger listeners</span></span><br><span class="line">useDogStore.<span class="title function_">setState</span>(&#123; <span class="attr">paw</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="comment">// Unsubscribe listeners</span></span><br><span class="line"><span class="title function_">unsub1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can of course use the hook as you always would</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> paw = <span class="title function_">useDogStore</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">paw</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="業務邏輯層-React-Hooks"><a href="#業務邏輯層-React-Hooks" class="headerlink" title="業務邏輯層: React Hooks"></a>業務邏輯層: React Hooks</h2><p><a href="https://linyencheng.github.io/2024/08/17/react/react-hooks/">為什麼要選擇 React Hooks?</a></p><blockquote><p>React Hooks 提供了一種更簡潔、更靈活的方式來管理狀態和副作用，使開發人員能夠更專注於業務邏輯的實現</p></blockquote><p>React Hooks 的出現是 Reactjs 發展史上的重要里程碑，讓副作用處理和加值功能能透過 hook 的方式整合進 functional component，相對 class 的處理能提供更簡單的寫法，像 redux 的 useSelector 就取代 connect 和 mapStateToProps。</p><p>React Hooks 的概念可以想像成是在登山背包上，透過外掛系統將需要的功能或需要的材料掛載到背包上，透過 hooks 將邏輯處理的函式和處理後的資料掛載到元件上。</p><blockquote><p><img src="https://pic2.zhimg.com/v2-33eb45debc551d28d565ad31d3b59599_b.webp?consumer=ZHI_MENG"><br>圖片來源: <a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/456354561?source_id=1003">https://www.zhihu.com/tardis/zm/art/456354561?source_id=1003</a></p></blockquote><p>React Hooks 由剛剛的說明來看就屬於外掛子系統的一個概念，所以在撰寫上也有要注意的規範</p><ol><li>只能在 function 中的最上層使用 hooks，不要在迴圈中或是判斷裡面執行，外掛系統必須跟著元件在產生的時候一起掛載上去，就像是登山背包出門發前就要將裝備準備齊全一樣</li><li>只能在 React Function 裡面使用 hooks 不能在一般的 JavaScript Function 中使用，因為 hooks 是專屬於 React 元件的外掛系統，就是像都已經出門登山了外掛的東西在半山腰突然修改一樣</li><li>不要動態的修改 hooks 的內容，外掛系統也是一個系統不要邊使用邊改變</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 只能掛載在最上層，且一開始就使用，而不是當作半路上的選配</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ChatInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">useData</span>=<span class="string">&#123;useDataWithLogging&#125;</span> /&gt;</span></span>; <span class="comment">// 🔴 Bad: don&#x27;t pass Hooks as props</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 不要動態的修改 hooks 的內容，外掛系統也是一個系統不要邊使用邊改變</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ChatInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> useDataWithLogging = <span class="title function_">withLogging</span>(useData); <span class="comment">// 🔴 Bad: don&#x27;t write higher order Hooks</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">useDataWithLogging</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API-Hooks-SWR、React-Query"><a href="#API-Hooks-SWR、React-Query" class="headerlink" title="API Hooks: SWR、React Query"></a>API Hooks: SWR、React Query</h3><p>舉個例子來說與後端 API 介面整合的部分，早期的寫法小編大多是透過定義 API Service 來進行處理。</p><p>在 Fetch 尚未普及時，Axios API 提供了一個不錯的解決方案，打 API 的時候，可能常常不只一個後端，不同後端也會需要有兩個不同的 token，放置的位置可能也不一樣，成功回覆的狀態碼也不同，失敗的情況也不大相同。所以如果當多個地方都需要同時打 A、B 兩個不同的 API 時，也代表多個地方都要進行類似的預&#x2F;後處理。</p><p>那 <a target="_blank" rel="noopener" href="https://github.com/axios/axios">axios</a> 透過產生 instance 的方式，幫我們統一處理了 request 發出前，接收 response 後，統一的預處理、後處理的問題。這樣只要在不同的地方使用 A、B instance 去進行 API 的串接即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = axios.<span class="title function_">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a request interceptor</span></span><br><span class="line">A.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something before request is sent</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something with request error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a response interceptor</span></span><br><span class="line">A.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something with response data</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something with response error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">A.<span class="title function_">get</span>(<span class="string">&quot;/api/path&quot;</span>);</span><br></pre></td></tr></table></figure><p>SWR 與 React Query 則提供了 hook 的解決方案，對於 API 資料的處理寫法上簡化了不少。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useSWR <span class="keyword">from</span> <span class="string">&quot;swr&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetcher</span> = (<span class="params">url</span>) =&gt; axios.<span class="title function_">get</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Profile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error, isLoading &#125; = <span class="title function_">useSWR</span>(<span class="string">&quot;/api/user&quot;</span>, fetcher);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>failed to load<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (isLoading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello &#123;data.name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>早期 API services 的設計在 hook 則透過客製化不同的 fetcher 來進行轉換，fetcher 依舊可以維持原來的作法，只是在元件中我們不再透過 <code>useEffect</code> 和 <code>useState</code> 來處理資料。</p><h2 id="展示層-JSX、CSS-in-JS"><a href="#展示層-JSX、CSS-in-JS" class="headerlink" title="展示層: JSX、CSS-in-JS"></a>展示層: JSX、CSS-in-JS</h2><p>Reactjs 使用 JSX 語法來描述 UI 界面，使其更易於理解和維護。</p><blockquote><p>DOM &#x3D; React(props, state)</p></blockquote><p>元件中的 JSX 會透過 <a target="_blank" rel="noopener" href="https://react.dev/reference/react/createElement">createElement</a> 這個 function 被轉換成 React Element。</p><h3 id="Reconciliation-Virtual-DOM、Fiber-Tree"><a href="#Reconciliation-Virtual-DOM、Fiber-Tree" class="headerlink" title="Reconciliation: Virtual DOM、Fiber Tree"></a>Reconciliation: Virtual DOM、Fiber Tree</h3><p><a target="_blank" rel="noopener" href="https://zh-hant.reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html">React Element</a> 是一個物件，包含 type 及 properties，type 用來區分是 component instance 或是 DOM node，Element 在 React 中又分成兩種</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Element (type 為 DOM node)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&#x27;button button-blue&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;OK!&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button <span class="keyword">class</span>=<span class="string">&#x27;button button-blue&#x27;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    OK!</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Component Element (type 為 instance)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">DeleteAccount</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="title class_">SubmitForm</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;Are you sure?&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Button</span>,</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;Cancel&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">DeleteAccount</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">SubmitForm</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Are you sure?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">color</span>=<span class="string">&#x27;blue&#x27;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">SubmitForm</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>當我們知道底層的定義之後，React 透過 Virtual DOM 減少了高成本的 DOM tree 操作，可以參考 <a target="_blank" rel="noopener" href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf">state of the art algorithms</a>，React 效能好就歸功於寫的程式碼並不會操作 DOM，而是會有以下特性:</p><ul><li>改變的狀態其實是操作我們常聽到的 Virtual DOM 或是 Fiber Tree</li><li>狀態對 UI 影響是<em>非同步</em>，如果狀態在一個循環內 <code>A -&gt; B -&gt; C -&gt; A</code> 這樣最後 DOM 就不會變化</li><li>相同 type，如果 attributes 改變則會偵測並變化 attribute</li><li>Reconciliation (fiber) 將複雜度減少到 O(n)</li></ul><p>React 也會這樣的資料結構中，處理狀態對於元件的改變，這個結構就是我們常聽的 Virtual DOM，有篇開箱文寫的很棒:</p><p><a target="_blank" rel="noopener" href="https://pomb.us/build-your-own-react/">https://pomb.us/build-your-own-react/</a></p><p>在這篇文章中可以看成是一棵 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Left-child_right-sibling_binary_tree">left-chlid right-sibling tree</a>:</p><ul><li>每一個 Node 有指向 Parent 的參考</li><li>過程先看有沒有 Child，再看有沒有 Sibling，都沒有才回到 Parent</li><li>整棵樹走完才 render 結果到實際的 DOM 上</li></ul><p>Reconciliation 就是一個演算法，找出哪些樹節點哪些需要變化，當我們呼叫 <code>render()</code> 的時候，React 會做一個 Top-Down 的 Reconciliation。</p><p>過程中會不停地去問你的 type 是什麼? 如果我們定義了一個 Component Elements X 且 type 是 Y，那 React 就會去問什麼是 Y，直到問到最基礎的組成為止。</p><p>Reconciliation 實作上會符合以下假設:</p><ul><li>不同 type，在 react 會產生不同的樹，不會去偵測而是直接取代</li><li>偵測一個 list 的改變會透過 keys 來增加效能</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2015&quot;</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2016&quot;</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2014&quot;</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2015&quot;</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2016&quot;</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="元件分類與週期-React-Class-Component、Functional-Component"><a href="#元件分類與週期-React-Class-Component、Functional-Component" class="headerlink" title="元件分類與週期: React Class Component、Functional Component"></a>元件分類與週期: React Class Component、Functional Component</h3><p>實際上元件中週期有哪些? 執行順序如何? 就像人有生老病死，元件從出現到消失主要也分三部分</p><blockquote><p>Mount -&gt; Updating -&gt; Unmounting</p></blockquote><p>React 要寫出一個元件，有 Class-based 或是 Functional 兩種方式，早期的 React Class Component 開發參雜了各種複雜的元件週期，也許是因為開發初期，所以將週期都拆解得很詳細，並且提供可以客製的型態，光是理解這些就讓開發的入門門檻提高不少。</p><ol><li>Mount: 已經出現在瀏覽器的 DOM 上<ul><li><code>constructor()</code></li><li><code>static getDerivedStateFromProps()</code></li><li><code>render()</code></li><li><code>componentDidMount()</code></li></ul></li><li>Updating: Props 或 State 變化後引發的元件更新<ul><li><code>getDerivedStateFromProps()</code></li><li><code>shouldComponentUpdate()</code></li><li><code>render()</code></li><li><code>getSnapshotBeforeUpdate()</code></li><li><code>componentDidUpdate()</code></li></ul></li><li>Unmounting: 從瀏覽器的 DOM 中移除<ul><li><code>componentWillUnmount()</code></li></ul></li></ol><p>另外元件從 Props 或 State 變化後引發改變的過程，主要分為兩大階段 Render 和 Commit，會先進行 Render 的計算後才會真的 Commit 結果到真正的 DOM 上面，Commit 前會有個 Pre-commit。</p><ol><li>Render: 在這個階段 React 能自行暫停、取消、重新這個過程</li><li>Pre-commit: 文件上有出現但甚少使用的功能，有一個週期是 <code>getSnapshotBeforeUpdate()</code>，可以看成是一個做決定前的再次狀態確認</li><li>Commit: 套用改變到瀏覽器的 DOM 上，而這是肉眼可見，也是我們較常操作的週期<ol><li><code>componentDidMount()</code>: Mount 成功，出現在 DOM 上面</li><li><code>componentDidUpdate()</code>: Props 或 State 改變</li><li><code>componentWillUnmount()</code>: 從 DOM 上移除</li></ol></li></ol><iframe width="100%" height="550" src="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>React 經過十年後，現在常見的 Functional Component 已經不再需要處理複雜的元件週期，取而代之的是理解關鍵元件週期並透過 hook 處理，當元件 props 或是 state 改變後，React 會透過 render 的演算法來決定最終要更新到 DOM 上面的改變，這個過程就是剛剛提到的 reconciliation。</p><p>雖然說透過 hook 能大量簡化元件本身的規則，但元件還是有一些基礎原則需要遵守一些原則來設計:</p><ol><li>冪等 (Idempotent): 這部分跟 API 設計一樣，React Funtional Component 本質上也還是一個 Function，所以將元件設計為 Pure Function 且保證每次的 Input 也就是 State 和 Props 不改的情況下，每次都要 Render 出同樣的結果</li><li>不在 Render 的地方處理 Side Effect: 元件本身可以看成一個 Declarative 的語言，理論上我們想要出現什麼就是什麼，React 只優化狀態改變後的 “下個版本” 該顯示什麼該怎麼改變畫面，會出現副作用讓畫面不同的地方通常只剩使用者操作事件或是後端 API 的資料不符合 Idempotent，當 Render 元件這件事變成純函式，React 也可以更容易的去優化</li><li>不去修改非元件內的資料: Props 跟 state 都是 immutable 也就是不要造成額外副作用的意思</li><li>元件用 JSX 的方式執行: 雖然 Functional Component 可以當成 Function 直接執行 <code>HelloComponent()</code>，但你會發現 React 開發者工具就無法處理 AKA React 並沒有辦法好好處理，建議方式還是 <code>&lt;HelloComponent /&gt;</code> 讓 React 正常執行上面提到的 createElement 產生正確的 Virtual Dom</li><li>元件裡面不要再有元件: 會讓元件檔案變大也很難做完全隔離的單元測試，這種寫法大概只能存在於重構到一半的程式碼</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: 元件只用 JSX 的方式執行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentOne</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ComponentOne</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentOne</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;() =&gt; &#123;return <span class="tag">&lt;&gt;</span>ComponentTwo<span class="tag">&lt;/&gt;</span></span>;&#125;()&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentOne</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">ComponentTwo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>ComponentTwo<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ComponentOne</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentOne</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;ComponentTwo()&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad: 元件裡面不要再有元件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentOne</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">ComponentTwo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>ComponentTwo<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ComponentOne</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentOne</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ComponentTwo</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentTwo</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentTwo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>ComponentTwo<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentOne</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ComponentOne</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentOne</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ComponentTwo</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentTwo</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元件開發-Storybookjs"><a href="#元件開發-Storybookjs" class="headerlink" title="元件開發: Storybookjs"></a>元件開發: Storybookjs</h3><p>此外 Storybook 也搭著這波元件的概念，發展出了 <a target="_blank" rel="noopener" href="https://www.componentdriven.org/">Component-based 的架構和開發方式</a>，這樣的概念其實就是大家熟悉的原子化設計，</p><ol><li>獨立開發每個元件，並為其不同變體撰寫故事 (測試案例)</li><li>將小型元件組合在一起以實現更複雜的功能</li><li>通過組合複合元件來組裝頁面</li><li>整合資料和業務邏輯將頁面整合到專案</li></ol><blockquote><p><img src="https://bradfrost.com/wp-content/uploads/2013/06/atomic-design.png"><br>圖片來源: <a target="_blank" rel="noopener" href="https://bradfrost.com/blog/post/atomic-web-design/">https://bradfrost.com/blog/post/atomic-web-design/</a></p></blockquote><p>底下的程式碼示範了一個最簡單的故事書設定，透過以下的設定我們就能夠輕鬆的獲得一個完全隔離的環境來進行元件開發，即使多人合作的專案也不容易互相衝突，設計出來的元件也會更容易符合單一責任原則。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Meta</span>, <span class="title class_">StoryObj</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@storybook/react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Histogram</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./Histogram&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">meta</span>: <span class="title class_">Meta</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Histogram</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Histogram</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> meta;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Story</span> = <span class="title class_">StoryObj</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Histogram</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Default</span>: <span class="title class_">Story</span> = &#123;</span><br><span class="line">  <span class="attr">args</span>: &#123;</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&quot;latency&quot;</span>,</span><br><span class="line">    <span class="attr">showHistogramLabels</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">histogramAccentColor</span>: <span class="string">&quot;#1EA7FD&quot;</span>,</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&quot;Latency distribution&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由於 component-based 的概念興起元件開發成為顯學，<a href="https://linyencheng.github.io/2022/09/10/relationships-between-frontend-and-backend/css-in-js-with-reactjs/">CSS-in-JS</a> 提供了將樣式寫在元件中解決方案，也讓 CSS 需要從寫程式語言的角度去進行架構設計。</p><p>開發上 <a href="https://linyencheng.github.io/2022/09/10/relationships-between-frontend-and-backend/css-in-js-with-reactjs/">CSS-in-JS</a> 的流行，當網頁三本柱 HTML、CSS、JavaScript 能夠完整的寫在同一個檔案時，也使 Reactjs 的 UI 開發更加靈活和一致，不僅降低了維護難度也加速了開發速度減少檔案切換，同時也減少 class 命名錯誤等等問題，讓元件成為真正高內聚的元件。</p><p>常見的 library 像是 css module、vanilla-extract、styled-components、styled-jsx (Next.js)、StyleX (Facebook) 都非常好上手，更完整的將元件模組化並增加可重用性。</p><div class="google-ad"><ins class="adsbygoogle" style="display:block" data-ad-format="fluid" data-ad-layout-key="-h4+1+1q-1t-2x" data-ad-client="ca-pub-1297466993744883" data-ad-slot="9012117796"></ins></div><hr><div class="more-article hidden-md hidden-lg"><span class="h4">更多相關文章</span><hr class="hidden-sm hidden-xs"><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-img"><img alt="yencheng" loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3><a href="/2020/02/02/react-component-class-based-vs-functional/" title="React Class-based vs Functional Component" rel="bookmark">React Class-based vs Functional Component</a></h3><span>2020-02-02<span></span></span></div></li><li class="popular-posts-item"><div class="popular-posts-img"><img alt="yencheng" loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3><a href="/2021/02/28/react-in-enterprise-app/" title="不在大型專案導入 React.js 的 5 個原因" rel="bookmark">不在大型專案導入 React.js 的 5 個原因</a></h3><span>2021-02-28<span></span></span></div></li><li class="popular-posts-item"><div class="popular-posts-img"><img alt="yencheng" loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3><a href="/2021/05/07/react-interview-questions/" title="你了解 React JS 嗎" rel="bookmark">你了解 React JS 嗎</a></h3><span>2021-05-07<span></span></span></div></li><li class="popular-posts-item"><div class="popular-posts-img"><img alt="yencheng" loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3><a href="/2017/09/21/react-intl/" title="React 多國語言簡介(使用 react-intl)" rel="bookmark">React 多國語言簡介(使用 react-intl)</a></h3><span>2017-09-21<span></span></span></div></li><li class="popular-posts-item"><div class="popular-posts-img"><img alt="yencheng" loading="lazy" src="/2017/05/18/thinking-component-state-and-props/state.png"></div><div class="popular-posts-title"><h3><a href="/2017/05/18/thinking-component-state-and-props/" title="Component State and Props" rel="bookmark">Component State and Props</a></h3><span>2017-05-18<span></span></span></div></li></ul></div><hr class="hidden-md hidden-lg"><span id="likeCo" class="pl-4 ml-4" style="color:#9b9b9b">喜歡這篇文章，請幫忙拍拍手喔 🤣</span><hr><div class="likecoin-embed likecoin-button" style="margin:0;max-height:185px;min-height:185px" data-liker-id="linyencheng-tw" data-href="https://linyencheng.github.io/2024/04/06/react-10-years-developer-experience"></div><hr><ul class="pager"><li class="previous"><a href="/2024/05/30/tool-vite-system-env/" data-toggle="tooltip" data-placement="top" title="Vite 系統環境變數">&larr; 上一篇</a></li><li class="next"><a href="/2024/02/02/cumulative-layout-shift/" data-toggle="tooltip" data-placement="top" title="Cumulative Layout Shift (CLS)">下一篇 &rarr;</a></li></ul><br><div class="p-2 google-ad"><ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-1297466993744883" data-ad-slot="1800981579"></ins></div><div class="comment"><div id="disqus_thread" class="disqus-thread"></div></div></div><div class="col-lg-3 col-lg-offset-0 visible-lg-block sidebar-container catalog-container sticky__sidebar"><h5 id="-1" class="p-0"><a class="catalog-toggle" href="#">站內搜尋</a></h5><div id="site_search"><div class="form-group mt-3"><input type="text" id="local-search-input" inputmode="search" name="q" results="0" autocomplete="off" placeholder="請輸入關鍵字" class="st-search-input st-default-search-input form-control"></div><div id="local-search-result"></div></div><div class="side-catalog"><h5 id="-1"><a class="catalog-toggle" href="#">其他相關文章</a></h5><hr class="hidden-sm hidden-xs"><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-img"><img alt="yencheng" loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3><a href="/2020/02/02/react-component-class-based-vs-functional/" title="React Class-based vs Functional Component" rel="bookmark">React Class-based vs Functional Component</a></h3><span>2020-02-02<span></span></span></div></li><li class="popular-posts-item"><div class="popular-posts-img"><img alt="yencheng" loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3><a href="/2021/02/28/react-in-enterprise-app/" title="不在大型專案導入 React.js 的 5 個原因" rel="bookmark">不在大型專案導入 React.js 的 5 個原因</a></h3><span>2021-02-28<span></span></span></div></li><li class="popular-posts-item"><div class="popular-posts-img"><img alt="yencheng" loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3><a href="/2021/05/07/react-interview-questions/" title="你了解 React JS 嗎" rel="bookmark">你了解 React JS 嗎</a></h3><span>2021-05-07<span></span></span></div></li></ul></div><div class="side-catalog mt-3"><h5 class="widget-title">最新的文章</h5><hr class="hidden-sm hidden-xs"><div class="widget"><ul class="p-0 popular-posts"><li class="popular-posts-item"><div class="popular-posts-img"><img loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3 id="progressive-web-app-1"><a href="/2025/08/10/kimetsu-no-yaiba/agatsuma-zenitsu-learn-one-thing/" title="我妻善逸教會我的事情" rel="bookmark">我妻善逸教會我的事情</a></h3><span>2025-08-11</span></div></li><li class="popular-posts-item"><div class="popular-posts-img"><img loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3 id="progressive-web-app-1"><a href="/2025/08/10/kimetsu-no-yaiba/kibutsuji-muzan-boss/" title="鬼舞辻無慘職場生存學" rel="bookmark">鬼舞辻無慘職場生存學</a></h3><span>2025-08-11</span></div></li><li class="popular-posts-item"><div class="popular-posts-img"><img loading="lazy" src="https://linyencheng.github.io/img/icon_48.png"></div><div class="popular-posts-title"><h3 id="progressive-web-app-1"><a href="/2025/08/09/kimetsu-no-yaiba/rengoku-kyoujurou-be-true-be-you/" title="炎柱的人生信念" rel="bookmark">炎柱的人生信念</a></h3><span>2025-08-11</span></div></li></ul></div></div><div class="side-catalog mt-3 google-ad"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1297466993744883" data-ad-slot="9240487898" data-ad-format="auto" data-full-width-responsive="true"></ins></div></div><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"></div></div></div></article><script>var disqus_shortname="linyencheng",disqus_identifier="https://linyencheng.github.io/2024/04/06/react-10-years-developer-experience/",disqus_url="https://linyencheng.github.io/2024/04/06/react-10-years-developer-experience/";function loadLikeCo(){var e;(e=document.createElement("script")).type="text/javascript",e.defer=!0,e.src="//static.like.co/sdk/v1/button.js",(document.head||document.body).appendChild(e)}function loadDisqus(){var e;(e=document.createElement("script")).type="text/javascript",e.defer=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}var runningOnBrowser="undefined"!=typeof window,isBot=runningOnBrowser&&!("onscroll"in window)||"undefined"!=typeof navigator&&/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent),supportsIntersectionObserver=runningOnBrowser&&"IntersectionObserver"in window;setTimeout(function(){var n;!isBot&&supportsIntersectionObserver?(n=new IntersectionObserver(function(e){e[0].isIntersecting&&(loadLikeCo(),n.disconnect())},{threshold:[0]})).observe(document.getElementById("likeCo")):loadLikeCo()},1),setTimeout(function(){var n;!isBot&&supportsIntersectionObserver?(n=new IntersectionObserver(function(e){e[0].isIntersecting&&(loadDisqus(),n.disconnect())},{threshold:[0]})).observe(document.getElementById("disqus_thread")):loadDisqus()},1)</script><script>function getQueryString(t){return Object.keys(t).map(e=>e+"="+t[e]).join("&")}function updateDom(e){e.result.viewCountTotal&&768<window.innerWidth&&(localStorage.setItem("2024%2F04%2F06%2Freact-10-years-developer-experience%2F",JSON.stringify(e)),document.getElementById("viewCountTotal").innerHTML='| 👀 <span class="pl-1">'+e.result.viewCountTotal+"</span>")}function getViewCount(){var e=getQueryString({url:"2024%2F04%2F06%2Freact-10-years-developer-experience%2F",title:"Reactjs%20%E5%95%8F%E4%B8%96%E5%8D%81%E5%B9%B4%E5%BE%8C%E7%9A%84%E9%96%8B%E7%99%BC%E9%AB%94%E9%A9%97",action:"read_viewCount"});fetch("https://script.google.com/macros/s/AKfycbzaNdmEmtd1OTLicwwL628yQsVLKV3eSkxKqIsgUZ3zVQKn2nAnCnrOGgMgT-T8364N/exec?"+e).then(e=>e.json()).then(e=>updateDom(e)).catch(e=>console.error(e))}function initViewCount(){var e=localStorage.getItem("2024%2F04%2F06%2Freact-10-years-developer-experience%2F");e&&updateDom(JSON.parse(e)),setTimeout(()=>{getViewCount()},800)}initViewCount()</script><style>@media all and (min-width:800px){.anchorjs-link{position:absolute;left:-.75em;font-size:1.1em;margin-top:-.1em}}@media all and (max-width:800px){.google-ad{max-height:140px}}</style><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target="_blank" rel="noopener" aria-label="YenCheng's Medium" href="https://linyencheng-tw.medium.com/"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-medium fa-stack-1x fa-inverse"></i></span></a></li><li><a title="Facebook" target="_blank" rel="noopener" aria-label="YenCheng's Facebook" href="https://www.facebook.com/linyencheng.3mins"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a title="Github" target="_blank" rel="noopener" aria-label="YenCheng's Github" href="https://github.com/LinYenCheng"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a title="Linkedin" target="_blank" rel="noopener" href="https://www.linkedin.com/in/LinYenCheng"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted"><a title="隱私權政策" href="/pravicy">隱私權政策</a> | Copyright &copy; 前端三分鐘 2025<br>Theme by <a title="原作者" target="_blank" rel="noopener" href="http://huangxuan.me">Hux</a> <span style="display:inline-block;margin:0 5px">& </span>Ported by <a title="第二作者" target="_blank" rel="noopener" href="https://github.com/Kaijun/hexo-theme-huxblog">Kaijun</a></p></div></div></div></footer><script defer>function loadScript(e,t){let n=document.createElement("script");n.src=e,n.defer=!0,n.onload=()=>t(null),n.onerror=e=>t(e),setTimeout(()=>{document.head.appendChild(n)},800)}function loadCSS(e,t){var n=document.createElement("link");n.rel="preload",n.href=e,n.as="style",document.head.appendChild(n);let l=document.createElement("link");l.rel="stylesheet",l.href=e,l.onload=()=>t(null),l.onerror=e=>t(e),setTimeout(()=>{document.head.appendChild(l)},800)}loadCSS("https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css",()=>{console.log("load font-awesome.min.css")}),loadScript("https://linyencheng.github.io/js/jquery.min.js",function(){var e=window,t=document,n="script",l="dataLayer";e[l]=e[l]||[],e[l].push({"gtm.start":(new Date).getTime(),event:"gtm.js"}),e=t.getElementsByTagName(n)[0],(l=t.createElement(n)).defer=!0,l.src="https://www.googletagmanager.com/gtm.js?id=GTM-W5LMXCR",e.parentNode.insertBefore(l,e),window.initViewCountAll&&window.initViewCountAll(),window.initViewCount&&window.initViewCount();{document.querySelectorAll("#toc .toc-item:has(> .toc-child)").forEach(n=>{var e=n.querySelector(".toc-link");let t=document.createElement("i");t.classList.add("fa","fa-caret-down");var l=document.createElement("i");l.classList.add("fa","fa-caret-right"),n.prepend(t,l),l.classList.add("hide"),n.querySelectorAll("i").forEach(t=>{t.addEventListener("click",function(){var e=n.querySelector(".toc-child");e.style.display="none"===e.style.display?"block":"none",t.classList.toggle("hide"),t.nextElementSibling.classList.toggle("hide")})}),e.addEventListener("dblclick",function(){n.querySelector(".toc-child").style.display="none",t.classList.toggle("hide")}),e.addEventListener("click",function(){var e=n.querySelector(".toc-child");e.style.display="none"===e.style.display?"block":"none",t.classList.toggle("hide")})});let t=document.querySelector("#toc .toc-title");t&&(t.classList.add("clickable"),t.addEventListener("click",function(){var e=t.nextElementSibling;"none"===e.style.display?(e.style.display="block",caretDown.classList.remove("hide"),caretRight.classList.add("hide")):(e.style.display="none",caretDown.classList.add("hide"),caretRight.classList.remove("hide"))}))}loadScript("https://linyencheng.github.io/js/bootstrap.min.js",function(){loadScript("https://linyencheng.github.io/js/hux-blog.min.js",function(){setTimeout(()=>{searchFunc("/search.xml","local-search-input","local-search-result")},3e3),document.getElementById("tag_cloud")&&loadScript("https://linyencheng.github.io/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})})})})</script></body></html>